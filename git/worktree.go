package git

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// WorktreeManager manages git worktrees for project isolation
type WorktreeManager struct {
	baseRepoPath string // Path to the main repository
	worktreesDir string // Directory where worktrees are created
}

// NewWorktreeManager creates a new worktree manager
func NewWorktreeManager(baseRepoPath, worktreesDir string) *WorktreeManager {
	return &WorktreeManager{
		baseRepoPath: baseRepoPath,
		worktreesDir: worktreesDir,
	}
}

// CreateWorktree creates a new git worktree for a project
func (wm *WorktreeManager) CreateWorktree(projectID, branchName string) (string, error) {
	log.Printf("Git Worktree: Creating worktree for project %s on branch %s", projectID, branchName)

	// Ensure worktrees directory exists
	if err := os.MkdirAll(wm.worktreesDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create worktrees directory: %w", err)
	}

	// Worktree path
	worktreePath := filepath.Join(wm.worktreesDir, projectID)

	// Check if worktree already exists
	if _, err := os.Stat(worktreePath); err == nil {
		log.Printf("Git Worktree: Worktree already exists at %s", worktreePath)
		return worktreePath, nil
	}

	// Create new branch and worktree
	cmd := exec.Command("git", "worktree", "add", "-b", branchName, worktreePath, "HEAD")
	cmd.Dir = wm.baseRepoPath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to create worktree: %w, output: %s", err, string(output))
	}

	log.Printf("Git Worktree: Created worktree at %s", worktreePath)
	return worktreePath, nil
}

// CommitChanges commits changes in a worktree
func (wm *WorktreeManager) CommitChanges(worktreePath, message string) error {
	log.Printf("Git Worktree: Committing changes in %s", worktreePath)

	// Check if there are changes to commit
	statusCmd := exec.Command("git", "status", "--porcelain")
	statusCmd.Dir = worktreePath
	statusOutput, err := statusCmd.Output()
	if err != nil {
		return fmt.Errorf("failed to check git status: %w", err)
	}

	if len(strings.TrimSpace(string(statusOutput))) == 0 {
		log.Printf("Git Worktree: No changes to commit")
		return nil
	}

	// Add all changes
	addCmd := exec.Command("git", "add", "-A")
	addCmd.Dir = worktreePath
	if output, err := addCmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to add changes: %w, output: %s", err, string(output))
	}

	// Commit with attribution
	commitCmd := exec.Command("git", "commit", "-m", message+"\n\nGenerated by AI Factory")
	commitCmd.Dir = worktreePath
	if output, err := commitCmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to commit changes: %w, output: %s", err, string(output))
	}

	log.Printf("Git Worktree: Changes committed successfully")
	return nil
}

// RemoveWorktree removes a worktree and cleans up
func (wm *WorktreeManager) RemoveWorktree(projectID string) error {
	worktreePath := filepath.Join(wm.worktreesDir, projectID)

	log.Printf("Git Worktree: Removing worktree at %s", worktreePath)

	// Check if worktree exists
	if _, err := os.Stat(worktreePath); os.IsNotExist(err) {
		log.Printf("Git Worktree: Worktree does not exist, skipping removal")
		return nil
	}

	// Remove worktree
	cmd := exec.Command("git", "worktree", "remove", worktreePath, "--force")
	cmd.Dir = wm.baseRepoPath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to remove worktree: %w, output: %s", err, string(output))
	}

	log.Printf("Git Worktree: Worktree removed successfully")
	return nil
}

// PruneWorktrees prunes stale worktree administrative files
func (wm *WorktreeManager) PruneWorktrees() error {
	log.Printf("Git Worktree: Pruning stale worktrees")

	cmd := exec.Command("git", "worktree", "prune")
	cmd.Dir = wm.baseRepoPath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to prune worktrees: %w, output: %s", err, string(output))
	}

	log.Printf("Git Worktree: Pruned stale worktrees")
	return nil
}

// ListWorktrees lists all active worktrees
func (wm *WorktreeManager) ListWorktrees() ([]string, error) {
	cmd := exec.Command("git", "worktree", "list", "--porcelain")
	cmd.Dir = wm.baseRepoPath

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to list worktrees: %w", err)
	}

	// Parse worktree list
	var worktrees []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "worktree ") {
			path := strings.TrimPrefix(line, "worktree ")
			worktrees = append(worktrees, path)
		}
	}

	return worktrees, nil
}

// GetDiff returns the git diff for a worktree
func (wm *WorktreeManager) GetDiff(worktreePath string) (string, error) {
	cmd := exec.Command("git", "diff", "HEAD")
	cmd.Dir = worktreePath

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get diff: %w", err)
	}

	return string(output), nil
}

// GetStatus returns the git status for a worktree
func (wm *WorktreeManager) GetStatus(worktreePath string) (string, error) {
	cmd := exec.Command("git", "status", "--short")
	cmd.Dir = worktreePath

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get status: %w", err)
	}

	return string(output), nil
}

// IsGitRepo checks if a directory is a git repository
func IsGitRepo(path string) bool {
	gitDir := filepath.Join(path, ".git")
	if _, err := os.Stat(gitDir); err == nil {
		return true
	}
	return false
}

// InitRepo initializes a new git repository
func InitRepo(path string) error {
	cmd := exec.Command("git", "init")
	cmd.Dir = path

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to init git repo: %w, output: %s", err, string(output))
	}

	log.Printf("Git: Initialized repository at %s", path)
	return nil
}
